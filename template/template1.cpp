// Todo : 템플릿(Template) 에 대한 이해와 함수 템플릿
// 템플릿에는 '모형자'라는 뜻이 담겨있다. 모형자는 모형을 그릴 때 사용한다. 빨간색 펜을 이용해서 모형을 그리면 빨간색 모형이 그려지고,
// 파란색 펜을 이용해서 모형을 그리면 파란색 모형이 그리지는 것이 모형자이다.

// Todo : 함수를 대상으로 템플릿 이해하기
// 모형자의 특징은 다음과 같다

// "모형을 만들어 낸다. 모형의 틀은 결정되어 있지만, 모형의 색은 결정되어 있지 않아서 결정해야 한다."

// 위의 문장에서 모형을 만들어 낸다는 것은 모형을 그린다는 뜻이다.

// 다음은 "함수 템플릿"의 특징이다.

// "함수 템플릿은 함수를 만들어 낸다. 함수의 기능은 결정되어 있지만, 자료형은 결정되어 있지 않아서 결정해야 한다."

// Todo : 함수를 만들어 낸다고?

// 그렇다! "함수 템플릿"이라는 것은 함수를 만드는 도구가 된다.
// 함수 템플릿도 다양한 자료형의 함수를 만들어 낼 수 있다.

T Add(T num1 , T num2 ) {
  return num1 + num2;
}

// 그런데 이것이 전부가 아니다. 우리는 컴파일러에게 다음과 같은 메시지를 전달해야 한다.

// "T는 자료형을 결정짓지 않겠다는 의미로 사용한 것입니다.즉 , 함수를 만들어 내는 템플릿을 정의하기 위해서 사용된 것이지요"
// 그리고 이러한 메시지를 담아서 위의 "함수 템플릿"은 다음과 같이 완성해야 한다.

template <typename T>
T Add(T num1 , T num2 ) {
  return num1 + num2;
}

// 이는 T 라는 이름을 이용해서 아래의 함수를 템플릿으로 정의한다는 의미이다.

// 또는 이와 같이 선언할 수 있다.
template <typename T>
template <class T>

// Todo : 예제
#include <iostream>
using namespace std;

template <typename T>
T Add(T num1 , T num2 ) {
  return num1 + num2;
}

int main(int argc, char const *argv[])
{
  cout<<Add<int>(15 , 20)<<endl;
  cout<<Add<double>(2.9 , 3.7)<<endl;

  return 0;
}

/*
35
6.6
*/

// Todo : "그럼 함수를 템플릿으로 정의하면 매 호출만장마다 함수를 만들게 되나요?"
// 아니다! 한번 함수가 만들어지면, 그 다음에는 만들어진 함수를 호출할 뿐 새로 함수를 만들지는 않는다.
// 문장을 컴파일 할 때 앞서 만들어 놓은 두 함수를 호출할 뿐이다.

// Todo : "컴파일 할 때 함수가 만들어진다고요? 그럼 그만큼 속도가 느리겠네요?"
// 물론 속도의 감소가 발생한다. 그런데 이는 컴파일 속도지 실행속도가 아니다. 컴파일 할 때 함수가 만들어 진다고 하지 않았는가?
// 때문에 컴파일 하는데 걸리는 시간이 느릴 뿐이지 실행속도에는 신경 쓸 요소가 아니다.

// Todo : 이렇게 호출해도 됩니다!

int main(int argc, char const *argv[])
{
  cout<<Add(15 , 20)<<endl;
  cout<<Add(2.9 , 3.7)<<endl;
  return 0;
}

/*
35
6.6
*/

// 즉, 일반함수를 호출하듯이 호출할 수도 있다. 왜냐하면, 전달되는 인자의 자료형을 참조하여 호출될 함수의 유형을 컴파일러가 결정하기 때문이다.

