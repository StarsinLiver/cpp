// Todo: 가상 함수의 동작원리와 가상함수 테이블
// 가상함수의 동작원리를 이해하면, C++이 C보다 느린 이유를 조금이나마 알 수 있게 된다.

#include <iostream>
using namespace std;
class AAA {
  private:
  int num1;
  public :
  virtual void Func1() {cout<<"Func1"<<endl;}
  virtual void Func2() {cout<<"Func2"<<endl;}
};

class BBB : public AAA {
  private :
  int num2;
  public :
  virtual void Func1() {cout<<"BBB : Func1"<<endl;}
  void Func3() {cout<<"Func3"<<endl;}
};

int main(int argc, char const *argv[])
{
  AAA * aptr = new AAA();
  aptr -> Func1();

  BBB * bptr = new BBB();
  bptr -> Func1(); 
  return 0;
}

/*
Func1
BBB : Func1
*/

// AAA 클래스와 BBB 클래스의 맴버변수들은 형식적으로 선언한 것이므로 무시해도 좋다. 그래서 맴버변수의 초기화에 필요한 생성자도 정의하지 않았다.
// 그럼 먼저 AAA 클래스를 보자
// virtual 로 선언된 가상함수가 존재한다. 이렇듯 한 개 이상의 가상함수를 포함하는 클래스에 대해서는 컴파일러가 다음 그림과 같은 '가상함수 테이블'이라는 것을 만든다.
// 이를 간단히 'V-Table(Virtual Table)'이라고도 하는데 이는 실제 호출되어야 할 함수의 위치정보를 담고 있는 테이블이다.

|key|value|
|:--:|:-:|
|void AAA::Func1()|0x1024번지|
|void AAA::Func2()|0x2048번지|

// 위의 가상함수 테이블을 보면, key 와 value 가 있다.
// 여기서 key 는 호출하고자 하는 함수를 구분지어주는 구분자의 역할을 한다.
// 그리고 value 는 구분자에 해당하는 함수의 주소정보를 알려주는 역할을 한다.
// 그래서 AAA 객체의 Func1 함수를 호출하는 경우, 위의 테이블에 첫 번째 행의 정보를 참조하여, 0x1024번지에 등록되어 있는 Func1 함수를 호출하게 되는 것이다.

// BBB 클래스를 보자 
// 역시 한개 이상의 가상함수를 포함하고 있으므로 다음의 형태로 가상함수 테이블이 생성된다.
|key|value|
|:--:|:-:|
|void BBB::Func1()|0x3072번지|
|void AAA::Func1()|0x2048번지|
|void BBB::Func3()|0x4096번지|

// 위의 가상함수 테이블을 보면 다음 특징이 있다.
// "AAA 클래스의 오버라이딩 된 가상함수 Func1에 대한 정보가 존재하지 않는다."

// 이렇듯, 오버라이딩된 가상함수의 주소정보는 유도 클래스의 가상함수 테이블에 포함되지 않는다. 때문에 오버라이딩 된 가상함수를 호출하면, 무조건 가장 마지막에 오버
// 라이디을 한 유도 클래스의 멤버함수가 호출되는 것이다.

// Todo : 가상함수 테이블이 참조되는 방식
// [].cpp 이 실행되면 main 함수가 호출되기 전에 다음의 구조로 가상함수 테이블이 메모리 공간에 할당된다. 참고로 가상함수 테이블은 객체의 생성과 상관없이
// 메모리 공간에 할당된다. 이는 가상함수 테이블이 멤버함수의 호출에 사용되는 일종의 데이터이기 때문이다.

// Todo : AAA V-Table
|key|value|
|:--:|:-:|
|void AAA::Func1()|0x1024번지|
|void AAA::Func2()|0x2048번지|

// Todo : BBB V-Table
|key|value|
|:--:|:-:|
|void BBB::Func1()|0x3072번지|
|void AAA::Func1()|0x2048번지|
|void BBB::Func3()|0x4096번지|

// 이어서, main 함수가 호출되어 객체가 생성되고 나면, 다음의 구조로 참조관계를 구성한다.
// page 382쪽

// 위의 그림에서 보여주듯이 AAA 객체에는 AAA 클래스의 가상함수 테이블의 주소값이 저장되고, BBB 객체에는 BBB 클래스의 가상함수 테이블의 주소 값이 저장된다.
// 즉, 가상함수를 하나이상 멤버로 지니는 클래스의 객체에는 가상함수 테이블의 주소 값이 저장된다.
// 물론 이 주소 값은 우리가 직접 참조할 수 있는 주소값이 아닌 내부적으로 필요에 의해서 참조되는 주소 값일 뿐이다.

// 위와 같은 상황에서 AAA 객체를 통해 Func1 을 호출하면 Func1 함수의 위치확인을 위해서 AAA 클래스의 가상함수 테이블을 참조하고, 결국 0x1024 번지에 위치한
// 함수가 실행된다.

// 이와 유사하게 BBB 객체의 Func1 함수가 호출되는 경우에는 BBB 클래스의 가상함수 테이블이 참조되고, 이 테이블에서는 함수의 위치를 0x3072번지로 기록하고 있으므로,
// 0x3072번지에 위치한 BBB 클래스의 Func1 함수가 실행된다.

// Todo : 결론
// 이제 결론이다. BBB 클래스의 가상함수 테이블을 살펴보면, 오버라이딩 된 AAA 클래스의 Func1 함수에 대한 정보가 없음을 알 수 있다.
// 그래서 BBB 클래스의 Func1 함수가 대신 호출하게 되는데, 이것이 바로 가상함수의 호출의 원리다.