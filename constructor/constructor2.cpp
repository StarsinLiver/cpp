// Todo : 자동으로 삽입이 되는 디폴트 복사 생성자
// 앞서 우리는 복사 생성자의 삽입 없이도 맴버 대 맴버의 복사가 진행된 것을 경험하였다.
// 그렇다면 이는 어떻게 가능한 것일까?

// "복사 생성자를 정의하지 않으면, 맴버 대 맴버의 복사를 진행하는 디폴트 복사 생성자가 자동으로 삽입된다."

// Todo : 변환에 의한 초기화! 키워드 explicit 으로 막을 수 있다.
// 복사생성자에 대한 첫 소개를 끝내기에 앞서 키워드 explicit 를 소개하고자 한다. 앞서 다음의 문장
// SoSimple sim2 = sim1;

// 다음의 형태로 묵시적 변환이 일어나서 복사 생성자가 호출된다.
// SoSimple sim2(sim1);

// 이는 결국 , 복사 생성자가 묵시적으로 호출되는 데 따라서 위와 같은 유형의 변환이 마음에 들지 않는다면 복사 생성자의 묵시적 호출을 허용하지 않으면 된다.
class SoSimple {
  int num1;
  int num2;
  explicit SoSimle(const SoSimple &copy) : num1(copy.num1) , num2 (copy.num2) {}
};

// 더 이상 묵시적 변환이 발생하지 않아서 대입 연산자를 이용한 객체의 생성 및 초기화는 불가능 하다.

// 그리고 이러한 문장의 묵시변 변환은 복사 생성자에서만 일어나는 것이 아니다. 전달인자가 하나인 생성자가 있다면, 이역시 묵시적 변환이 발생한다.
// 예를 들어서 다음과 같이 정의된 클래스가 있다면

class AAA {
  private :
  int num;
  public :
  AAA(int n) : num(n) {}
};

// 다음의 문장을 통해서 객체 생성이 가능하다.
AAA obj = 3; // AAA obj(3); 으로 변환

// 그리고 이 경우에도 마찬가지로 키워드 explicit 가 생성자에 선언되면, 묵시적인 변환을 허용하지 않기때문에 다음의 형태로 객체를 생성할 수 밖에 없다.
